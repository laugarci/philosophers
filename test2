#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#define AMARILLO_T "\x1b[33m"
#define VERDE_T "\x1b[32m"
#define AZUL_T "\x1b[34m"

typedef struct t_info {
    int     num_philo;
    int     time_to_die;
    int     time_to_eat;
    int     time_to_sleep;
    int     num_times_must_eat;
    int     num_forks;
    long    start_time;
}           t_info;

typedef struct t_philo {
    int                     philo_id;
    int                     num_meals;
    pthread_mutex_t         left_fork;
    pthread_mutex_t         right_fork;
    pthread_t               threads;
    struct t_info           *info;
}                           t_philo;

int create_all_mutex(t_philo *philo, t_info *info)
{
    int i;

    i = 0;
    while (i < info->num_philo)
    {
        pthread_mutex_init(&(philo[i].left_fork), NULL);
        pthread_mutex_init(&(philo[i].right_fork), NULL);
        i++;
    }
    return (0);
}

void start_think(t_philo *philo)
{
    printf(AMARILLO_T"%d %s\n", philo->philo_id, "is thinking");
    usleep(10000);
}

void start_eat(t_philo *philo)
{
    printf(VERDE_T"%d %s\n", philo->philo_id, "has taken left fork");
    printf(VERDE_T"%d %s\n", philo->philo_id, "has taken right fork");
    printf(VERDE_T"%d %s\n", philo->philo_id, "is eating");
    usleep(10000);
}

void start_sleep(t_philo *philo)
{
    printf(AZUL_T"%d %s\n", philo->philo_id, "is sleeping");
    usleep(10000);
}

void *start_routine(void *ph)
{
    t_philo  *philo;

    philo = (t_philo *)ph;
    while (42)
    {
 clear
 pthread_mutex_lock(&(philo->left_fork));
        pthread_mutex_lock(&(philo->right_fork));
        start_eat(philo);
        pthread_mutex_unlock(&(philo->left_fork));
        pthread_mutex_unlock(&(philo->right_fork));
        start_think(philo);
        start_sleep(philo);
        if (philo->num_meals == philo->info->num_times_must_eat)
            break ;
    }
    return (NULL);
}

int create_threads(t_philo *philo, t_info *info)
{
    long        i;

    philo = (t_philo*)malloc(sizeof(t_philo) * info->num_philo); // protect malloc
    create_all_mutex(philo, info);
    i = 0;
    while (i < info->num_philo)
    {
        philo[i].philo_id = i + 1;
        philo[i].info = info;
        pthread_create(&(philo[i].threads), NULL, start_routine, &(philo[i]));
        i++;
    }
    i = 0;
    while (i < info->num_philo)
    {
        pthread_join(philo[i].threads, NULL);
        i++;
    }

    i = 0;
    while (i < info->num_philo)
    {
        pthread_mutex_destroy(&(philo[i].left_fork));
        pthread_mutex_destroy(&(philo[i].right_fork));
        i++;
    }
    free(philo);
    return 0;
}
