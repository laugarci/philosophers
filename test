#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define AMARILLO_T "\033[33m"
#define VERDE_T "\033[32m"
#define AZUL_T "\033[34m"

typedef struct t_info {
    int     num_philo;
    int     time_to_die;
    int     time_to_eat;
    int     time_to_sleep;
    int     num_times_must_eat;
    int     num_forks;
    long    start_time;
} t_info;

typedef struct t_philo {
    int                 philo_id;
    int                 num_meals;
    pthread_mutex_t     left_fork;
    pthread_mutex_t     right_fork;
    pthread_t           threads;
    struct t_info       *info;
} t_philo;

int create_all_mutex(t_philo **philo, t_info **info)
{
    int i;

    i = 0;
    while (i < (*info)->num_philo)
    {
        pthread_mutex_init(&((*philo)[i].left_fork), NULL);
        pthread_mutex_init(&((*philo)[i].right_fork), NULL);
        i++;
    }
    return (0);
}

void start_think(t_philo *philo)
{
    printf(AMARILLO_T"%d %s\n", philo->philo_id, "is thinking");
    usleep(10000);
}

void start_eat(t_philo *philo)
{
    printf(VERDE_T"%d %s\n", philo->philo_id, "has taken left fork");
    printf(VERDE_T"%d %s\n", philo->philo_id, "has taken right fork");
    printf(VERDE_T"%d %s\n", philo->philo_id, "is eating");
    philo->num_meals++;
    usleep(10000);
}

void start_sleep(t_philo *philo)
{
    printf(AZUL_T"%d %s\n", philo->philo_id, "is sleeping");
    usleep(10000);
}

void *start_routine(void *ph)
{
    t_philo  *philo;

    philo = (t_philo *)ph;
    while (42)
    {
        pthread_mutex_lock(&philo->left_fork);
        pthread_mutex_lock(&philo->right_fork);
        start_eat(philo);
        pthread_mutex_unlock(&philo->left_fork);
        pthread_mutex_unlock(&philo->right_fork);
        start_think(philo);
        start_sleep(philo);
        if (philo->num_meals == philo->info->num_times_must_eat)
            break ;
    }
    return (NULL);
}

int create_threads(t_philo *philo, t_info *info)
{
    long        i;

    philo = (t_philo*)malloc(sizeof(t_philo) * info->num_philo);
    if (!philo)
    {
        // Manejo de error en caso de que malloc falle
        return -1;
    }
    create_all_mutex(&philo, &info);
    i = 0;
    while (i < info->num_philo)
    {
        philo[i].philo_id = i + 1;
        philo[i].info = info;
        pthread_create(&philo[i].threads, NULL, start_routine, &philo[i]);
        i++;
    }
    i = 0;
    while (i < info->num_philo)
    {
        pthread_join(philo[i].threads, NULL);
        i++;
    }

    i = 0;
    while (i < info->num_philo)
    {
        pthread_mutex_destroy(&philo[i].left_fork);
        pthread_mutex_destroy(&philo[i].right_fork);
        i++;
    }
    free(philo);
    return 0;
}

int main()
{
    t_info info;
    info.num_philo = 5;
    info.time_to_die = 200;
    info.time_to_eat = 200;
    info.time_to_sleep = 200;
    info.num_times_must_eat = 7;
    info.num_forks = 5;
    info.start_time = 0;

    create_threads(NULL, &info);

    return 0;
}

